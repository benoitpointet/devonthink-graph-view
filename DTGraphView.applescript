use AppleScript version "2.4" -- Yosemite (10.10) or lateruse scripting additionsuse framework "Foundation"-- classes, constants, and enums usedproperty NSJSONSerialization : a reference to current application's NSJSONSerializationproperty NSJSONWritingPrettyPrinted : a reference to 0property maxDepth : a reference to 1property idleTime : 5 -- in seconds-- showJSON :: a -> String-- from https://forum.latenightsw.com/t/writing-json-data-with-nsjsonserialization/1130on toJSON(x)	set c to class of x	if (c is list) or (c is record) then		set ca to current application		set {json, e} to ca's NSJSONSerialization's dataWithJSONObject:x options:NSJSONWritingPrettyPrinted |error|:(reference)		if json is missing value then			e's localizedDescription() as text		else			(ca's NSString's alloc()'s initWithData:json encoding:(ca's NSUTF8StringEncoding)) as text		end if	else if c is date then		"\"" & ((x - (time to GMT)) as «class isot» as string) & ".000Z" & "\""	else if c is text then		"\"" & x & "\""	else if (c is integer or c is real) then		x as text	else if c is class then		"null"	else		try			x as text		on error			("«" & c as text) & "»"		end try	end ifend toJSONon labelify(theName, max)	if length of theName is less than max then		return theName	else		return text 1 thru max of theName	end ifend labelifyon nodify(theItem)	set theColor to "#333"	-- todo cleanup: clarify why i need the context here	tell application id "DNtp"		set theType to get type of theItem as string		if theType is "group" then set theColor to "#1af"	end tell	set newNode to {|id|:get id of theItem as string, label:my labelify(get name of theItem as string, 128), x:(random number from 0 to 1000), y:(random number from 0 to 1000), |color|:theColor}	return newNodeend nodifyon edgify(itemA, itemB)	set idA to get id of itemA as string	set idB to get id of itemB as string	set newEdge to {|id|:idA & "-" & idB, source:idA, target:idB}	return newEdgeend edgifyon graphItemsSet(theList)	tell application id "DNtp"		set nodes to {}		set nodeIDs to {}		set edges to {}		set edgeIDs to {}				-- first pass to graph nodes		repeat with theItem in theList			if nodeIDs does not contain (id of theItem as string) then				set node to my nodify(theItem)				set end of nodes to node				set end of nodeIDs to |id| of node			end if		end repeat				-- second pass to graph edges		repeat with theItem in theList			repeat with childItem in children of theItem				if nodeIDs contains (id of childItem as string) then					set edge to my edgify(theItem, childItem)					if edgeIDs does not contain (|id| of edge) then						set end of edgeIDs to |id| of edge						set end of edges to edge					end if				end if							end repeat		end repeat	end tell	return {nodes, edges}end graphItemsSeton run	tell application id "DNtp"				-- prepare graph data for items set in frontmost window		set theWindow to viewer window 1				-- if a search or not		if search results of theWindow is not {} then			set theSelection to search results of theWindow		else			set theSelection to selection			if theSelection is {} then				set theSelection to children of current group			end if			set end of theSelection to current group		end if				-- generate graph		set {nodes, edges} to my graphItemsSet(theSelection)		-- display alert (length of nodes as string) & " nodes, " & (length of edges as string) & " edges"		set theJSONData to my toJSON({nodes:nodes, edges:edges})				-- open the html and inject graph data		set theJS to "graphThis(" & (theJSONData as text) & ");ra"		set posixPath to POSIX path of ((path to me as text) & "::")		set graphWindowPath to "file://" & posixPath & "index.html"		set graphWindow to open tab for URL graphWindowPath		set theResult to do JavaScript theJS in graphWindow		set index of think window of graphWindow to 1	end tellend run